// the state machine will be used to transition between states
// the lifecycle of the state machine will be as follows:
// start in the 'enter' state with a set direction
// `fill` the cell we are in before moving to the next cell
// we move to `detect` state which will detect the next cell
// depending on the detector we will either `walk` to the next
// cell in the current direction, `turn` to the next direction,
// or `exit` if we have detected no valid options.
// In the case of `turn` and `walk` we will then `fill` the cell
// we are in before moving to the `detect` state.
// In the case of `exit` let the program know that we have exited

import {
  Cell,
  Direction,
  GetNextCellHandler,
  GetNextDirectionHandler,
} from 'lib/grid/types';

// and it can either stop or re-`enter` depending on the config.
export type State =
  | 'enter' // start of the walk
  | 'fill' // fill the cell we are in
  | 'detect' // detect the next cell
  | 'walk' // walk to the next cell
  | 'turn' // turn to the next direction
  | 'backtrack' // backtrack to the previous leg
  | 'exit' // end the current walk
  | 'complete'; // end the program

/**
 * the unwalked cell data is generated before the walk has started
 */
export interface UnwalkedCellData {
  /** the original index of the cell */
  index: number;

  /** flag to indicate if the cell has been walked */
  walked: false;

  /** the coordinate of the cell */
  cell: Cell;

  /** total number of cells */
  totalCellCount: number;
}

/**
 * the first pass position data is generated during the actual walk
 * and describes the metadata of the cell we are currently observing.
 */
export interface WalkedCellPositionData {
  /** the number of cells we have made **/
  stepCount: number;

  /** the number of legs/turns we have made **/
  legCount: number;
}

/**
 * the first pass data is generated during the actual walk and
 * describes the metadata of the cell we are currently observing.
 **/
export interface WalkedCellData extends Omit<UnwalkedCellData, 'walked'> {
  /** the original index of the cell */
  index: number;

  /** flag to indicate if the cell has been walked */
  walked: true;

  /** the cell we are currently observing */
  cell: Cell;

  /** the previous cell we walked from */
  previousCell: Cell | null;

  /** the next cell we are walking to */
  nextCell: Cell | null;

  /** the direction we are entering from */
  direction: Direction;

  /** the current path count */
  currentPathCount: number;

  /** absolute position data is the cell data since the start of the program */
  absolute: WalkedCellPositionData;

  /** relative position data is the cell data since the last `enter` state */
  relative: WalkedCellPositionData;
}

/**
 * Once we've walked the cell we can provide additional metadata
 * about the cell we are currently observing.
 */
export interface EnrichedCellPositionData extends WalkedCellPositionData {
  /** total number of steps made since the start of the program */
  totalStepCount: number;

  /** total number of legs/turns we have walked */
  totalLegCount: number;
}

/**
 * walked data is generated by reprocessing the first pass data
 * and adding additional metadata.
 *
 * The term `absolute` refers to the cell data since the start
 * of the program, while the term `relative` refers to the cell
 * data since the last `enter` state.
 */
export interface EnrichedCellData extends WalkedCellData {
  /** previous cell we walked from */
  previousCellData: EnrichedCellData | null;

  /** next cell we are walking to */
  nextCellData: EnrichedCellData | null;

  /** flag to indicate if this is the first cell in the path */
  isHead: boolean;

  /** flag to indicate if this is the last cell in the path */
  isTail: boolean;

  /** the number of paths we have walked */
  totalPathCount: number;

  /** total number of walked cells */
  totalWalkedCellCount: number;

  /** the absolute position data is the cell data since the start of the program */
  absolute: EnrichedCellPositionData;

  /** the relative position data is the cell data since the last `enter` state */
  relative: EnrichedCellPositionData;
}

export interface ProgramState {
  currentState: State;
  currentCell: Cell;
  previousCell: Cell | null;
  nextCell: Cell | null;
  currentDirection: Direction;
  absoluteStepCount: number;
  absoluteLegCount: number;
  relativeStepCount: number[];
  relativeLegCount: number[];
  currentLegStepCount: number;
  lastLegStepCount: number;
  maxLegCount: number | null;
  totalPathCount: number;
  totalWalkedCellCount: number;
  failCount: number;
  unwalkedCellData: Map<string, UnwalkedCellData>;
  walkedCellData: Map<string, WalkedCellData>;
}

export type StateTransitionHandler = (
  state: ProgramState,
  config: Required<ProgramConfig>
) => void;

/**
 * the program conig is used to congigure the state machine
 */
export interface ProgramConfig {
  /** the starting cell when the program starts */
  initialCell?: Cell;

  /** the starting direction when the program starts */
  initialDirection?: Direction;

  /** the number of cells in the grid */
  gridSize: Cell;

  /** the maximum number of walks we will make */
  maxPathCount?: number;

  /** the maximum number of cells we will walk */
  maxPathSteps?: number;

  /** the maximum number of legs/turns we will make */
  maxLegCount?: number;

  /** the maximum number of steps we will make on a leg */
  maxLegSteps?: number;

  /** the maximum number of times we will fail to detect a next cell */
  maxFailCount?: number;

  /** function which returns the next cell */
  getNextCell?: GetNextCellHandler<ProgramState>;

  /** function which returns the next direction */
  getNextDirection?: GetNextDirectionHandler<ProgramState>;

  /** state transition handlers */
  handleEnterState?: StateTransitionHandler;
  handleDetectState?: StateTransitionHandler;
  handleFillState?: StateTransitionHandler;
  handleWalkState?: StateTransitionHandler;
  handleTurnState?: StateTransitionHandler;
  handleExitState?: StateTransitionHandler;
}

export type InternalCellData =
  | UnwalkedCellData
  | WalkedCellData
  | EnrichedCellData;

export type CellData = UnwalkedCellData | EnrichedCellData;
